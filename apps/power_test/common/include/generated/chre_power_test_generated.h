// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
#define FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace power_test {

struct TimerMessage;

struct WifiScanMessage;

struct GnssLocationMessage;

struct CellQueryMessage;

struct AudioRequestMessage;

struct SensorRequestMessage;

struct BreakItMessage;

struct NanoappResponseMessage;

/// Indicates which of the following messages is being sent to / from the
/// nanoapp. Use uint as the base type to match the message type in
/// chreMessageFromHostData.
enum class MessageType : uint32_t {
  UNSPECIFIED = 0  /// Should be used with TimerMessage
,
  TIMER_TEST = 1  /// Should be used with WifiScanMessage
,
  WIFI_SCAN_TEST = 2  /// Should be used with GnssLocationMessage
,
  GNSS_LOCATION_TEST = 3  /// Should be used with CellQueryMessage
,
  CELL_QUERY_TEST = 4  /// Should be used with AudioRequestMessage
,
  AUDIO_REQUEST_TEST = 5  /// Should be used with SensorRequestMessage
,
  SENSOR_REQUEST_TEST = 6  /// Should be used with BreakItMessage
,
  BREAK_IT_TEST = 7  /// Should be used with NanoappResponseMessage
,
  NANOAPP_RESPONSE = 8,
  MIN = UNSPECIFIED,
  MAX = NANOAPP_RESPONSE
};

inline const char **EnumNamesMessageType() {
  static const char *names[] = {
    "UNSPECIFIED",
    "TIMER_TEST",
    "WIFI_SCAN_TEST",
    "GNSS_LOCATION_TEST",
    "CELL_QUERY_TEST",
    "AUDIO_REQUEST_TEST",
    "SENSOR_REQUEST_TEST",
    "BREAK_IT_TEST",
    "NANOAPP_RESPONSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

/// All the various sensors that can be interacted with inside the nanoapp.
/// The values used here map directly to values from the CHRE API
enum class SensorType : uint8_t {
  UNKNOWN = 0,
  ACCELEROMETER = 1,
  INSTANT_MOTION_DETECT = 2,
  STATIONARY_DETECT = 3,
  GYROSCOPE = 6,
  UNCALIBRATED_GYROSCOPE = 7,
  GEOMAGNETIC_FIELD = 8,
  UNCALIBRATED_GEOMAGNETIC_FIELD = 9,
  PRESSURE = 10,
  LIGHT = 12,
  PROXIMITY = 13,
  STEP_DETECT = 23,
  UNCALIBRATED_ACCELEROMETER = 55,
  ACCELEROMETER_TEMPERATURE = 56,
  GYROSCOPE_TEMPERATURE = 57,
  GEOMAGNETIC_FIELD_TEMPERATURE = 58,
  MIN = UNKNOWN,
  MAX = GEOMAGNETIC_FIELD_TEMPERATURE
};

inline const char **EnumNamesSensorType() {
  static const char *names[] = {
    "UNKNOWN",
    "ACCELEROMETER",
    "INSTANT_MOTION_DETECT",
    "STATIONARY_DETECT",
    "",
    "",
    "GYROSCOPE",
    "UNCALIBRATED_GYROSCOPE",
    "GEOMAGNETIC_FIELD",
    "UNCALIBRATED_GEOMAGNETIC_FIELD",
    "PRESSURE",
    "",
    "LIGHT",
    "PROXIMITY",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "STEP_DETECT",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "UNCALIBRATED_ACCELEROMETER",
    "ACCELEROMETER_TEMPERATURE",
    "GYROSCOPE_TEMPERATURE",
    "GEOMAGNETIC_FIELD_TEMPERATURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSensorType()[index];
}

/// Represents a message to ask the nanoapp to create a timer that wakes up at
/// the given interval
struct TimerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_WAKEUP_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t wakeup_interval_ns() const {
    return GetField<uint64_t>(VT_WAKEUP_INTERVAL_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_WAKEUP_INTERVAL_NS) &&
           verifier.EndTable();
  }
};

struct TimerMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(TimerMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_wakeup_interval_ns(uint64_t wakeup_interval_ns) {
    fbb_.AddElement<uint64_t>(TimerMessage::VT_WAKEUP_INTERVAL_NS, wakeup_interval_ns, 0);
  }
  TimerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerMessageBuilder &operator=(const TimerMessageBuilder &);
  flatbuffers::Offset<TimerMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TimerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerMessage> CreateTimerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t wakeup_interval_ns = 0) {
  TimerMessageBuilder builder_(_fbb);
  builder_.add_wakeup_interval_ns(wakeup_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop WiFi scanning and
/// the scan interval to use if scanning is being started
struct WifiScanMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t scan_interval_ns() const {
    return GetField<uint64_t>(VT_SCAN_INTERVAL_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_SCAN_INTERVAL_NS) &&
           verifier.EndTable();
  }
};

struct WifiScanMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_ns(uint64_t scan_interval_ns) {
    fbb_.AddElement<uint64_t>(WifiScanMessage::VT_SCAN_INTERVAL_NS, scan_interval_ns, 0);
  }
  WifiScanMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiScanMessageBuilder &operator=(const WifiScanMessageBuilder &);
  flatbuffers::Offset<WifiScanMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<WifiScanMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiScanMessage> CreateWifiScanMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t scan_interval_ns = 0) {
  WifiScanMessageBuilder builder_(_fbb);
  builder_.add_scan_interval_ns(scan_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop Gnss location
/// sampling at the requested interval
struct GnssLocationMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_MILLIS = 6,
    VT_MIN_TIME_TO_NEXT_FIX_MILLIS = 8
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint32_t scan_interval_millis() const {
    return GetField<uint32_t>(VT_SCAN_INTERVAL_MILLIS, 0);
  }
  uint32_t min_time_to_next_fix_millis() const {
    return GetField<uint32_t>(VT_MIN_TIME_TO_NEXT_FIX_MILLIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_INTERVAL_MILLIS) &&
           VerifyField<uint32_t>(verifier, VT_MIN_TIME_TO_NEXT_FIX_MILLIS) &&
           verifier.EndTable();
  }
};

struct GnssLocationMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(GnssLocationMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_millis(uint32_t scan_interval_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_SCAN_INTERVAL_MILLIS, scan_interval_millis, 0);
  }
  void add_min_time_to_next_fix_millis(uint32_t min_time_to_next_fix_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_MIN_TIME_TO_NEXT_FIX_MILLIS, min_time_to_next_fix_millis, 0);
  }
  GnssLocationMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GnssLocationMessageBuilder &operator=(const GnssLocationMessageBuilder &);
  flatbuffers::Offset<GnssLocationMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GnssLocationMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<GnssLocationMessage> CreateGnssLocationMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint32_t scan_interval_millis = 0,
    uint32_t min_time_to_next_fix_millis = 0) {
  GnssLocationMessageBuilder builder_(_fbb);
  builder_.add_min_time_to_next_fix_millis(min_time_to_next_fix_millis);
  builder_.add_scan_interval_millis(scan_interval_millis);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop querying the cell
/// modem for the latest cell scan results on the given interval
struct CellQueryMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_QUERY_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t query_interval_ns() const {
    return GetField<uint64_t>(VT_QUERY_INTERVAL_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_QUERY_INTERVAL_NS) &&
           verifier.EndTable();
  }
};

struct CellQueryMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(CellQueryMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_query_interval_ns(uint64_t query_interval_ns) {
    fbb_.AddElement<uint64_t>(CellQueryMessage::VT_QUERY_INTERVAL_NS, query_interval_ns, 0);
  }
  CellQueryMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellQueryMessageBuilder &operator=(const CellQueryMessageBuilder &);
  flatbuffers::Offset<CellQueryMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CellQueryMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellQueryMessage> CreateCellQueryMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t query_interval_ns = 0) {
  CellQueryMessageBuilder builder_(_fbb);
  builder_.add_query_interval_ns(query_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start / stop requesting Audio
/// data buffered at given interval. Note: If there is more than one audio
/// source, the nanoapp will only request audio from the first source.
struct AudioRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_BUFFER_DURATION_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  /// The buffer duration is also used as the interval for how often
  /// the buffer should be delivered to the nanoapp.
  uint64_t buffer_duration_ns() const {
    return GetField<uint64_t>(VT_BUFFER_DURATION_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_BUFFER_DURATION_NS) &&
           verifier.EndTable();
  }
};

struct AudioRequestMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(AudioRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_buffer_duration_ns(uint64_t buffer_duration_ns) {
    fbb_.AddElement<uint64_t>(AudioRequestMessage::VT_BUFFER_DURATION_NS, buffer_duration_ns, 0);
  }
  AudioRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioRequestMessageBuilder &operator=(const AudioRequestMessageBuilder &);
  flatbuffers::Offset<AudioRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AudioRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioRequestMessage> CreateAudioRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t buffer_duration_ns = 0) {
  AudioRequestMessageBuilder builder_(_fbb);
  builder_.add_buffer_duration_ns(buffer_duration_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start / stop sampling / batching
/// a given sensor
struct SensorRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4,
    VT_SENSOR = 6,
    VT_SAMPLING_INTERVAL_NS = 8,
    VT_LATENCY_NS = 10
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  SensorType sensor() const {
    return static_cast<SensorType>(GetField<uint8_t>(VT_SENSOR, 0));
  }
  uint64_t sampling_interval_ns() const {
    return GetField<uint64_t>(VT_SAMPLING_INTERVAL_NS, 0);
  }
  uint64_t latency_ns() const {
    return GetField<uint64_t>(VT_LATENCY_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint8_t>(verifier, VT_SENSOR) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLING_INTERVAL_NS) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY_NS) &&
           verifier.EndTable();
  }
};

struct SensorRequestMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_sensor(SensorType sensor) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_SENSOR, static_cast<uint8_t>(sensor), 0);
  }
  void add_sampling_interval_ns(uint64_t sampling_interval_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_SAMPLING_INTERVAL_NS, sampling_interval_ns, 0);
  }
  void add_latency_ns(uint64_t latency_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_LATENCY_NS, latency_ns, 0);
  }
  SensorRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorRequestMessageBuilder &operator=(const SensorRequestMessageBuilder &);
  flatbuffers::Offset<SensorRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SensorRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorRequestMessage> CreateSensorRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    SensorType sensor = SensorType::UNKNOWN,
    uint64_t sampling_interval_ns = 0,
    uint64_t latency_ns = 0) {
  SensorRequestMessageBuilder builder_(_fbb);
  builder_.add_latency_ns(latency_ns);
  builder_.add_sampling_interval_ns(sampling_interval_ns);
  builder_.add_sensor(sensor);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to enable / disable break-it mode inside the nanoapp.
/// Break-it mode enables WiFi / GNSS / Cell to be queried every second and
/// enables all sensors at their fastest sampling rate.
struct BreakItMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENABLE = 4
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           verifier.EndTable();
  }
};

struct BreakItMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(BreakItMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  BreakItMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BreakItMessageBuilder &operator=(const BreakItMessageBuilder &);
  flatbuffers::Offset<BreakItMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<BreakItMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BreakItMessage> CreateBreakItMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false) {
  BreakItMessageBuilder builder_(_fbb);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Indicates whether the nanoapp successfully performed the requested action.
/// Any failures will be printed to the logs.
struct NanoappResponseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct NanoappResponseMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(NanoappResponseMessage::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  NanoappResponseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappResponseMessageBuilder &operator=(const NanoappResponseMessageBuilder &);
  flatbuffers::Offset<NanoappResponseMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<NanoappResponseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappResponseMessage> CreateNanoappResponseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  NanoappResponseMessageBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

}  // namespace power_test
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
