#!/usr/bin/python3
#
# Copyright (C) 2020 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Note: originally written against pyclibrary v0.1.4 and Python 3.7+

import argparse
import json
import os.path
import subprocess
from collections import defaultdict
from datetime import datetime

from pyclibrary import CParser

LICENSE_HEADER = """/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"""


def system_chre_abs_path():
    """Gets the absolute path to the system/chre directory containint this script."""
    script_dir = os.path.dirname(os.path.realpath(__file__))
    # Assuming we're at system/chre/chpp/api_parser (i.e. up 2 to get to system/chre)
    chre_project_base_dir = os.path.normpath(script_dir + "/../..")
    return chre_project_base_dir


class StructGenerator:
    """Given an ApiParser object, generates a header file with structure definitions in CHPP format.
    """

    def __init__(self, api):
        """
        :param api: ApiParser object
        """
        self.api = api
        self.json = api.json

    def _autogen_notice(self):
        out = []
        out.append("// This file was automatically generated by {}\n".format(
            os.path.basename(__file__)))
        out.append("// Date: {} UTC\n".format(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')))
        commit_hash = subprocess.getoutput('git describe --always --long --dirty')
        out.append("// Source: {} @ commit {}\n\n".format(self.json['filename'], commit_hash))
        out.append("// DO NOT modify this file directly, as those changes will be lost the next\n")
        out.append("// time the script is executed\n\n")
        return out

    def _gen_includes(self):
        """Generates #include directives"""
        out = ["#include <stdint.h>\n\n"]

        includes = ["chpp/macros.h", "chre_api/chre/version.h"]
        includes.extend(self.json['output_includes'])
        for incl in sorted(includes):
            out.append("#include \"{}\"\n".format(incl))
        out.append("\n")
        return out

    def _get_member_comment(self, member_info):
        for annotation in member_info['annotations']:
            if annotation['annotation'] == "fixed_value":
                return "  // Input ignored; always set to {}".format(annotation['value'])
            elif annotation['annotation'] == "var_len_array":
                return "  // References {} instances of {}".format(
                    annotation['length_field'], self._get_member_type(member_info))
        return ""

    def _get_member_type(self, member_info):
        """Gets the type specification prefix for a struct/union member.

        :param member_info: a dict element from self.api.structs_and_unions[struct]['members']
        :return: type specification string that prefixes the field name, e.g. 'uint8_t'
        """
        # 4 cases to handle:
        #   1) Annotation gives explicit type that we should use
        #   2) Annotation says this is a variable length array (so use ChppOffset)
        #   3) This is a struct/union type, so use the renamed type
        #   4) Regular type, e.g. uint32_t, so just use the type spec as-is
        for annotation in member_info['annotations']:
            if annotation['annotation'] == "rewrite_type":
                return annotation['type_override']
            elif annotation['annotation'] == "var_len_array":
                return "struct ChppOffset"

        if len(member_info['type'].declarators) > 0 and member_info['type'].declarators[0] == "*":
            # This case should either be handled by rewrite_type (e.g. to uint32_t as
            # opaque/ignored), or var_len_array
            raise RuntimeError("Pointer types require annotation\n{}".format(
                member_info))

        type_spec = member_info['type'].type_spec
        if type_spec.startswith('struct ') or type_spec.startswith('union '):
            return self._get_struct_or_union_name(type_spec.split(' ')[1])

        return type_spec

    def _get_member_type_suffix(self, member_info):
        # If this is an array type, declarators will be a tuple containing a list of a single int
        # element giving the size of the array
        declarators = member_info['type'].declarators
        if len(declarators) == 1 and isinstance(declarators[0], list):
            return "[{}]".format(member_info['type'].declarators[0][0])
        return ""

    def _get_struct_or_union_name(self, name):
        prefix = 'struct ' if not self.api.structs_and_unions[name]['is_union'] else 'union '

        # First see if we have an explicit name override (e.g. for anonymous types)
        for annotation in self.api.annotations[name]["."]:
            if annotation['annotation'] == "rename_type":
                return prefix + annotation['type_override']

        # Otherwise, use the existing type name, just replace the "chre" prefix with "Chpp"
        if name.startswith('chre'):
            return prefix + 'Chpp' + name[4:]
        else:
            raise RuntimeError("Couldn't figure out new type name for {}".format(name))

    def _gen_struct_or_union(self, name):
        """Generates the definition for a single struct/union type"""
        out = []
        if not name.startswith('anon'):
            out.append("//! See {{@link {}}} for details\n".format(name))
        out.append("{} {{\n".format(self._get_struct_or_union_name(name)))
        for member_info in self.api.structs_and_unions[name]['members']:
            out.append("    {} {}{};{}\n".format(self._get_member_type(member_info),
                                                 member_info['name'],
                                                 self._get_member_type_suffix(member_info),
                                                 self._get_member_comment(member_info)))

        out.append("} CHPP_PACKED_ATTR;\n\n")
        return out

    def _gen_structs_and_unions(self):
        """Generates definitions for all struct/union types required for the root structs."""
        out = []
        out.append("CHPP_PACKED_START\n\n")

        sorted_structs = self._sorted_structs(self.json['root_structs'])
        for type_name in sorted_structs:
            out.extend(self._gen_struct_or_union(type_name))

        out.append("CHPP_PACKED_END\n\n")
        return out

    def _sorted_structs(self, root_nodes):
        """Implements a topological sort on self.api.structs_and_unions.

        Elements are ordered by definition dependency, i.e. if A includes a field of type B,
        then B will appear before A in the returned list.
        :return: list of keys in self.api.structs_and_unions, sorted by dependency order
        """
        result = []
        visited = set()

        def sort_helper(collection, key):
            for dep in sorted(collection[key]['dependencies']):
                if dep not in visited:
                    visited.add(dep)
                    sort_helper(collection, dep)
            result.append(key)

        for node in sorted(root_nodes):
            sort_helper(self.api.structs_and_unions, node)
        return result

    def generate_header_file(self, dry_run=False):
        """Creates a C header file for this API and writes it to the file indicated in the JSON."""
        self.header = self.generate_header_string()
        output_file = os.path.join(system_chre_abs_path(), self.json['output_file'])

        if dry_run:
            print("---- {} ----".format(output_file))
            print(self.header)
            print("---- end of {} ----\n".format(output_file))
        else:
            with open(output_file, 'w') as f:
                f.write(self.header)

    def generate_header_string(self):
        """Returns a C header with structure definitions for this API."""
        # To defer concatenation (speed things up), build the file as a list of strings then only
        # concatenate once at the end
        out = [LICENSE_HEADER]

        header_guard = "CHPP_"
        header_guard += self.json['output_file'].split("/")[-1].split(".")[0].upper()
        header_guard += "_H_"

        out.append("#ifndef {}\n#define {}\n\n".format(header_guard, header_guard))
        out.extend(self._autogen_notice())
        out.extend(self._gen_includes())
        out.append("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n")
        out.extend(self._gen_structs_and_unions())

        out.append("#ifdef __cplusplus\n}\n#endif\n\n")
        out.append("#endif  // {}\n".format(header_guard))
        return ''.join(out)


class ApiParser:
    """Given a file-specific set of annotations (extracted from JSON annotations file), parses a
    single API header file into data structures suitable for use with code generation.
    """

    def __init__(self, json_obj):
        """Initialize and parse the API file described in the provided JSON-derived object.

        :param json_obj: Extracted file-specific annotations from JSON
        """
        self.json = json_obj
        self.structs_and_unions = {}
        self._parse_annotations()
        self._parse_api()

    def _parse_annotations(self):
        # Convert annotations list to a more usable data structure: dict keyed by structure name,
        # containing a dict keyed by field name, containing a list of annotations (as they
        # appear in the JSON). In other words, we can easily get all of the annotations for the
        # "version" field in "chreWwanCellInfoResult" via
        # annotations['chreWwanCellInfoResult']['version']. This is also a defaultdict, so it's safe
        # to access if there are no annotations for this structure + field; it'll just give you
        # an empty list in that case.
        self.annotations = defaultdict(lambda: defaultdict(list))
        for struct_info in self.json['struct_info']:
            for annotation in struct_info['annotations']:
                self.annotations[struct_info['name']][annotation['field']].append(annotation)

    def _files_to_parse(self):
        """Returns a list of files to supply as input to CParser"""
        # Input paths for CParser are stored in JSON relative to <android_root>/system/chre
        # Reformulate these to absolute paths, and add in some default includes that we always
        # supply
        chre_project_base_dir = system_chre_abs_path()
        default_includes = ["chpp/api_parser/parser_defines.h",
                            "chre_api/include/chre_api/chre/version.h"]
        files = default_includes + self.json['includes'] + [self.json['filename']]
        return [os.path.join(chre_project_base_dir, file) for file in files]

    def _parse_structs_and_unions(self):
        # Starting with the root structures (i.e. those that will appear at the top-level in one
        # or more CHPP messages), build a data structure containing all of the information we'll
        # need to emit the CHPP structure definition and conversion code.
        structs_and_unions_to_parse = self.json['root_structs'].copy()
        while len(structs_and_unions_to_parse) > 0:
            type_name = structs_and_unions_to_parse.pop()
            if type_name in self.structs_and_unions:
                continue

            entry = {'members': [], 'dependencies': set()}
            if type_name in self.parser.defs['structs']:
                defs = self.parser.defs['structs'][type_name]
                entry['is_union'] = False
            elif type_name in self.parser.defs['unions']:
                defs = self.parser.defs['unions'][type_name]
                entry['is_union'] = True
            else:
                raise RuntimeError("Couldn't find {} in parsed structs/unions".format(type_name))

            for member_name, member_type, _ in defs['members']:
                entry['members'].append({
                    'name': member_name,
                    'type': member_type,
                    'annotations': self.annotations[type_name][member_name]
                })

                if member_type.type_spec.startswith('struct ') or \
                        member_type.type_spec.startswith('union '):
                    member_type_name = member_type.type_spec.split(' ')[1]
                    entry['dependencies'].add(member_type_name)
                    structs_and_unions_to_parse.append(member_type_name)

            self.structs_and_unions[type_name] = entry

    def _parse_api(self):
        file_to_parse = self._files_to_parse()
        self.parser = CParser(file_to_parse, cache='parser_cache')
        self._parse_structs_and_unions()


def run(args):
    with open('chre_api_annotations.json') as f:
        js = json.load(f)

    for file in js:
        api_parser = ApiParser(file)
        StructGenerator(api_parser).generate_header_file(args.dry_run)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate CHPP serialization code from CHRE APIs.')
    parser.add_argument('-n', dest='dry_run', action='store_true',
                        help='Print the output instead of writing to a file')
    args = parser.parse_args()
    run(args)
